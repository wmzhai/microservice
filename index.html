<!DOCTYPE html><html><!-- Built with spec-md --><head><meta charset="utf-8"><title>微服务</title><link href="spec.css" rel="stylesheet"><link href="highlight.css" rel="stylesheet"></head><body><header><h1>微服务</h1><div class="spec-toc"><ol><li><a href="#sec-undefined.-"><span class="spec-secid">1</span>简介</a><ol><li><a href="#sec--SOA"><span class="spec-secid">1.1</span>微服务与SOA</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">1.2</span>微服务架构定义</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">1.3</span>总结</a></li></ol></li><li><a href="#sec-undefined.-"><span class="spec-secid">2</span>客户端访问微服务</a><ol><li><a href="#sec-undefined.-.-"><span class="spec-secid">2.1</span>示例问题</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">2.2</span>客户端到微服务直接通信</a></li><li><a href="#sec-undefined.-.-API-Gateway"><span class="spec-secid">2.3</span>采用一个API Gateway</a></li><li><a href="#sec-API-Gateway-"><span class="spec-secid">2.4</span>API Gateway的优点和缺点</a></li><li><a href="#sec-undefined.-.-API-Gateway"><span class="spec-secid">2.5</span>实现一个API Gateway</a><ol><li><a href="#sec-undefined.-.-API-Gateway.-"><span class="spec-secid">2.5.1</span>性能和可扩展性</a></li><li><a href="#sec-undefined.-.-API-Gateway.-"><span class="spec-secid">2.5.2</span>采用反应性编程模型</a></li><li><a href="#sec-undefined.-.-API-Gateway.-"><span class="spec-secid">2.5.3</span>服务调用</a></li><li><a href="#sec-undefined.-.-API-Gateway.-"><span class="spec-secid">2.5.4</span>服务发现</a></li><li><a href="#sec-undefined.-.-API-Gateway.-"><span class="spec-secid">2.5.5</span>处理部分失败</a></li></ol></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">2.6</span>总结</a></li></ol></li><li><a href="#sec-undefined.-"><span class="spec-secid">3</span>服务间通信</a><ol><li><a href="#sec-undefined.-.-"><span class="spec-secid">3.1</span>简介</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">3.2</span>交互模式</a></li><li><a href="#sec--API"><span class="spec-secid">3.3</span>定义API</a></li><li><a href="#sec-API-"><span class="spec-secid">3.4</span>API的演化</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">3.5</span>处理部分失败</a></li><li><a href="#sec-IPC-"><span class="spec-secid">3.6</span>IPC技术</a><ol><li><a href="#sec-IPC-.-"><span class="spec-secid">3.6.1</span>异步的，基于消息通信</a></li><li><a href="#sec--IPC"><span class="spec-secid">3.6.2</span>同步的，基于请求/响应的IPC</a><ol><li><a href="#sec-REST"><span class="spec-secid">3.6.2.1</span>REST</a></li><li><a href="#sec-Thrift"><span class="spec-secid">3.6.2.2</span>Thrift</a></li><li><a href="#sec--IPC.-"><span class="spec-secid">3.6.2.3</span>消息格式</a></li></ol></li></ol></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">3.7</span>总结</a></li></ol></li><li><a href="#sec-undefined.-"><span class="spec-secid">4</span>服务发现</a><ol><li><a href="#sec-undefined.-.-"><span class="spec-secid">4.1</span>为什么要使用服务发现?</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">4.2</span>客户端发现模式</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">4.3</span>服务端发现</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">4.4</span>服务注册表</a></li><li><a href="#sec-undefined.-.-"><span class="spec-secid">4.5</span>服务注册选项</a><ol><li><a href="#sec-undefined.-.-.-"><span class="spec-secid">4.5.1</span>自注册方式</a></li><li><a href="#sec-undefined.-.-.-"><span class="spec-secid">4.5.2</span>第三方注册模式</a></li></ol></li></ol></li><li><a href="#sec-undefined.-"><span class="spec-secid">A</span>参考</a></li></ol></div></header><section id="sec-undefined.-"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">1</a></span>简介</h2><p>微服务架构（Microservice Architect）是一种架构模式，它提倡将单块架构的应用划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。</p><p>微服务是互联网高速发展，敏捷、精益、持续交付方法论的深入人心，虚拟化技术与DevOps文化的快速发展以及传统单块架构无法适应快速变化等多重因素的推动下所诞生的产物。</p><section id="sec--SOA"><h3><span class="spec-secid" title="link to this section"><a href="#sec--SOA">1.1</a></span>微服务与SOA</h3><p>早在1996年，Gartner就提出面向服务架构（SOA）。SOA阐述了&ldquo;对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组功能提供者组织在一起为消费者提供服务&rdquo;，其目的是为了解决企业内部不同IT资源之间无法互联而导致的信息孤岛问题。但是，由于SOA本身的广义性以及抽象性，在其诞生的相当长一段时间内，人们对SOA存在着不同的认知和理解。</p><p>实际上，微服务架构并不是一个全新的概念。仔细分析SOA的概念，就会发现，其和我们今天所谈到的微服务思想几乎一致。鉴于过去十几年互联网行业的高速发展，以及敏捷、持续集成、持续交付、DevOps，云技术等的深入人心，服务架构的开发、测试、部署以及监控等，相比我们提到的传统的SOA实现，已经大相径庭，主要区别如下表所示：</p><table><thead><tr><th>SOA </th><th>微服务 </th></tr></thead><tbody><tr><td>企业级，自顶向下开展实施	</td><td>团队级，自底向上开展实施</td></tr><tr><td>服务由多个子系统组成，粒度大 </td><td>一个系统被拆分成多个服务，粒度细 </td></tr><tr><td>企业服务总线，集中式的服务架构	</td><td>无集中式总线，松散的服务架构 </td></tr><tr><td>集成方式复杂（ESB/WS/SOAP）	 </td><td>集成方式简单（HTTP/REST/JSON） </td></tr><tr><td>单块架构系统，相互依赖，部署复杂	</td><td>服务都能独立部署 </td></tr></tbody></table><p>相比传统SOA的服务实现方式，微服务更具有灵活性、可实施性以及可扩展性，其强调的是一种独立测试、独立部署、独立运行的软件架构模式。</p></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">1.2</a></span>微服务架构定义</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><p>总结下来，微服务架构中的核心部分包括以下几点：</p><ul><li>小, 且专注于做⼀件事情</li><li>独立的进程中</li><li>轻量级的通信机制</li><li>松耦合、独立部署</li></ul></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">1.3</a></span>总结</h3><p>随着市场的快速发展，业务的不断扩大，单块架构应用面临着越来越多的挑战，其改造与重构势在必行。而微服务架构的诞生，是互联网高速发展，虚拟化技术应用以及持续交付、DevOps深入人心的综合产物。随着用户需求个性化、产品生命周期变短，微服务架构是未来软件软件架构朝着灵活性、扩展性、伸缩性以及高可用性发展的必然方向。同时，以Docker为代表的容器虚拟化技术的盛行，将大大降低微服务实施的成本，为微服务落地以及大规模使用提供了坚实的基础和保障。 </p></section></section><section id="sec-undefined.-"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">2</a></span>客户端访问微服务</h2><p>当决定将应用作为一组微服务时，需要决定应用客户端如何与微服务交互。在单体式程序中，通常只有一组冗余的或者负载均衡的服务提供点。在微服务架构中，每一个微服务暴露一组细粒度的服务提供点。在本篇文章中，我们来看它如何影响客户端到服务端通信，同时提出一种API Gateway的方法。</p><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">2.1</a></span>示例问题</h3><p>假定你正在为在线购物应用开发一个原生手机客户端。你需要实现一个产品最终页来展示商品信息。例如，下面的图展示了你在亚马逊Android客户端上滑动产品最终页时看到的信息。</p><p><img src="http://dockerone.com/uploads/article/20150701/815d48350a8d3a4b11df4a62e6df077d.png" alt="fig1"/></p><p>虽然这是一个智能手机应用，这个产品最终页展示了非常多的信息。例如，不仅这里有产品基本信息（名字、描述和价格），还有以下内容：</p><ul><li>购物车中的物品数</li><li>下单历史</li><li>用户评论</li><li>低库存警告</li><li>快递选项</li><li>各式各样的推荐，包括经常跟这个物品一起被购买的产品、购买该物品的其他顾客购买的产品以及购买该产品的顾客还浏览了哪些产品。</li><li>可选的购物选项</li></ul><p>当采用一个单体式应用架构，一个移动客户端将会通过一个REST请求（GET api.company.com/productdetails/productId）来获取这些数据。一个负载均衡将请求分发到多个应用实例之一。应用将查询各种数据库并返回请求给客户端。</p><p>相对的，若是采用微服务架构，最终页上的数据会分布在不同的微服务上。下面列举了可能与产品最终页数据有关的一些微服务：</p><ul><li>购物车服务 -- 购物车中的物品数</li><li>下单服务 -- 下单历史</li><li>分类服务 -- 基本产品信息，如名字、图片和价格</li><li>评论服务 -- 用户评论</li><li>库存服务 -- 低库存警告</li><li>快递服务 -- 快递选项、截止时间、来自不同快递API的成本计算</li><li>推荐服务 -- 推荐产品</li></ul><p><img src="http://dockerone.com/uploads/article/20150701/dd914aa3f02ef4e8e820ce0238d2dbab.png" alt="serv"/></p><p>我们需要决定移动客户端如何访问这些服务。请看下面这几种方式</p></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">2.2</a></span>客户端到微服务直接通信</h3><p>理论上说，一个客户端可以直接给多个微服务中的任何一个发起请求。每一个微服务都会有一个对外服务端(https://serviceName.api.company.name)。这个URL可能会映射到微服务的负载均衡上，它再转发请求到具体节点上。为了搜索产品细节，移动端需要向上述微服务逐个发请求。</p><p>不幸的是，这个方案有很多困难和限制。其中一个问题是客户端的需求量与每个微服务暴露的细粒度API数量的不匹配。如图中，客户端需要7次单独请求。在更复杂的场景中，可能会需要更多次请求。例如，亚马逊的产品最终页要请求数百个微服务。虽然一个客户端可以通过LAN发起很多个请求，但是在公网上这样会很没有效率，这个问题在移动互联网上尤为突出。这个方案同时会导致客户端代码非常复杂。</p><p>另一个存在的问题是客户端直接请求微服务的协议可能并不是web友好型。一个服务可能是用Thrift的RPC协议，而另一个服务可能是用AMQP消息协议。它们都不是浏览或防火墙友好的，并且最好是内部使用。应用应该在防火墙外采用类似HTTP或者WEBSocket协议。</p><p>这个方案的另一个缺点是它很难重构微服务。随着时间的推移，我们可能需要改变系统微服务目前的切分方案。例如，我们可能需要将两个服务合并或者将一个服务拆分为多个。但是，如果客户端直接与微服务交互，那么这种重构就很难实施。</p><p>由于上述三种问题的原因，客户端直接与服务器端通信的方式很少在实际中使用。</p></section><section id="sec-undefined.-.-API-Gateway"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway">2.3</a></span>采用一个API Gateway</h3><p>通常来说，一个更好的解决办法是采用API Gateway的方式。API Gateway是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade模式很像。API Gateway封装内部系统的架构，并且提供API给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的API Gateway。</p><p><img src="http://dockerone.com/uploads/article/20150701/e3af5a60b71f3d3fef53c1a5ccbfad78.png" alt="gateway"/></p><p>API Gateway负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过API Gateway，然后路由这些请求到对应的微服务。API Gateway将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在web协议与内部使用的非Web友好型协议间进行转换，如HTTP协议、WebSocket协议。</p><p>API Gateway可以提供给客户端一个定制化的API。它暴露一个粗粒度API给移动客户端。以产品最终页这个使用场景为例。API Gateway提供一个服务提供点（/productdetails?productid=xxx）使得移动客户端可以在一个请求中检索到产品最终页的全部数据。API Gateway通过调用多个服务来处理这一个请求并返回结果，涉及产品信息、推荐、评论等。</p><p>一个很好的API Gateway例子是Netfix API Gateway。Netflix流服务提供数百个不同的微服务，包括电视、机顶盒、智能手机、游戏系统、平板电脑等。起初，Netflix视图提供一个适用全场景的API。但是，他们发现这种形式不好用，因为涉及到各式各样的设备以及它们独特的需求。现在，他们采用一个API Gateway来提供容错性高的API，针对不同类型设备有相应代码。事实上，一个适配器处理一个请求平均要调用6到8个后端服务。Netflix API Gateway每天处理数十亿的请求。</p></section><section id="sec-API-Gateway-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-API-Gateway-">2.4</a></span>API Gateway的优点和缺点</h3><p>API Gateway也是优缺点并存的。API Gateway的一个最大好处是封装应用内部结构。相比起来调用指定的服务，客户端直接跟gatway交互更简单点。API Gateway提供给每一个客户端一个特定API，这样减少了客户端与服务器端的通信次数，也简化了客户端代码。</p><p>API Gateway也有一些缺点。它是一个高可用的组件，必须要开发、部署和管理。还有一个问题，它可能成为开发的一个瓶颈。开发者必须更新API Gateway来提供新服务提供点来支持新暴露的微服务。更新API Gateway时必须越轻量级越好。否则，开发者将因为更新Gateway而排队列。但是，除了这些缺点，对于大部分的应用，采用API Gateway的方式都是有效的。</p></section><section id="sec-undefined.-.-API-Gateway"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway">2.5</a></span>实现一个API Gateway</h3><p>既然我们已经知道了采用API Gateway的动机和优缺点，下面来看在设计它时需要考虑哪些事情。</p><section id="sec-undefined.-.-API-Gateway.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway.-">2.5.1</a></span>性能和可扩展性</h4><p>只有少数公司需要处理像Netflix那样的规模，每天需要处理数十亿的请求。但是，对于大多数应用，API Gateway的性能和可扩展性也是非常重要的。因此，创建一个支持同步、非阻塞I/O的API Gateway是有意义的。已经有不同的技术可以用来实现一个可扩展的API Gateway。在JVM上，采用基于NIO技术的框架，如Netty，Vertx，Spring Reactor或者JBoss Undertow。Node.js是一个非JVM的流行平台，它是一个在Chrome的JavaScript引擎基础上建立的平台。一个可选的方案是NGINX Plus。NGINX Plus提供一个成熟的、可扩展的、高性能web服务器和反向代理，它们均容易部署、配置和二次开发。NGINX Plus可以管理授权、权限控制、负载均衡、缓存并提供应用健康检查和监控。</p></section><section id="sec-undefined.-.-API-Gateway.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway.-">2.5.2</a></span>采用反应性编程模型</h4><p>对于有些请求，API Gateway可以通过直接路由请求到对应的后端服务上的方式来处理。对于另外一些请求，它需要调用多个后端服务并合并结果来处理。对于一些请求，例如产品最终页面请求，发给后端服务的请求是相互独立的。为了最小化响应时间，API Gateway应该并发的处理相互独立的请求。但是，有时候请求之间是有依赖的。API Gateway可能需要先通过授权服务来验证请求，然后在路由到后端服务。类似的，为了获得客户的产品愿望清单，需要先获取该用户的资料，然后返回清单上产品的信息。这样的一个API 组件是Netflix Video Grid。</p><p>利用传统的同步回调方法来实现API合并的代码会使得你进入回调函数的噩梦中。这种代码将非常难度且难以维护。一个优雅的解决方案是采用反应性编程模式来实现。类似的反应抽象实现有Scala的Future，Java8的CompletableFuture和JavaScript的Promise。基于微软.Net平台的有Reactive Extensions(Rx)。Netflix为JVM环境创建了RxJava来使用他们的API Gateway。同样地，JavaScript平台有RxJS，可以在浏览器和Node.js平台上运行。采用反应编程方法可以帮助快速实现一个高效的API Gateway代码。</p></section><section id="sec-undefined.-.-API-Gateway.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway.-">2.5.3</a></span>服务调用</h4><p>一个基于微服务的应用是一个分布式系统，并且必须采用线程间通信的机制。有两种线程间通信的方法。一种是采用异步机制，基于消息的方法。这类的实现方法有JMS和AMQP。另外的，例如Zeromq属于服务间直接通信。还有一种线程间通信采用同步机制，例如Thrift和HTTP。事实上一个系统会同时采用同步和异步两种机制。由于它的实现方式有很多种，因此API Gateway就需要支持多种通信方式。</p></section><section id="sec-undefined.-.-API-Gateway.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway.-">2.5.4</a></span>服务发现</h4><p>API Gateway需要知道每一个微服务的IP和端口。在传统应用中，你可能会硬编码这些地址，但是在现在云基础的微服务应用中，这将是个简单的问题。基础服务通常会采用静态地址，可以采用操作系统环境变量来指定。但是，探测应用服务的地址就没那么容易了。应用服务通常动态分配地址和端口。同样的，由于扩展或者升级，服务的实例也会动态的改变。因此，API Gateway需要采用系统的服务发现机制，要么采用服务端发现，要么是客户端发现。后续的一篇文章将会更详细的介绍这部分。如果采用客户端发现服务，API Gateway必须要去查询服务注册处，也就是微服务实例地址的数据库。</p></section><section id="sec-undefined.-.-API-Gateway.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-API-Gateway.-">2.5.5</a></span>处理部分失败</h4><p>在实现API Gateway过程中，另外一个需要考虑的问题就是部分失败。这个问题发生在分布式系统中当一个服务调用另外一个服务超时或者不可用的情况。API Gateway不应该被阻断并处于无限期等待下游服务的状态。但是，如何处理这种失败依赖于特定的场景和具体服务。例如，如果是在产品详情页的推荐服务模块无响应，那么API Gateway应该返回剩下的其他信息给用户，因为这些信息也是有用的。推荐部分可以返回空，也可以返回固定的顶部10个给用户。但是，如果是产品信息服务无响应，那么API Gateway就应该给客户端返回一个错误。</p><p>在缓存有效的时候，API Gateway应该能够返回缓存。例如，由于产品价格变化并不频繁，API Gateway在价格服务不可用时应该返回缓存中的数值。这类数据可以由API Gateway自身来缓存，也可以由Redis或Memcached这类外部缓存实现。通过返回缓存数据或者默认数据，API Gateway来确保系统错误不影响到用户体验。</p><p>Netflix Hystrix对于实现远程服务调用代码来说是一个非常好用的库。Hystrix记录那些超过预设定的极限值的调用。它实现了circuit break模式，使得可以将客户端从无响应服务的无尽等待中停止。如果一个服务的错误率超过预设值，Hystrix将中断服务，并且在一段时间内所有请求立刻失效。Hystrix可以为请求失败定义一个fallback操作，例如读取缓存或者返回默认值。如果你在用JVM，就应该考虑使用Hystrix。如果你采用的非JVM环境，那么应该考虑采用类似功能的库。</p></section></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">2.6</a></span>总结</h3><p>对于大多数微服务基础的应用，实现一个API Gateway都是有意义的，它就像是进入系统的一个服务提供点。API Gateway负责请求转发、请求合成和协议转换。它提供给应用客户端一个自定义的API。API Gateway可以通过返回缓存或者默认值的方式来掩盖后端服务的错误。在本系列的下一篇文章中，我们将讨论服务间的通信问题。</p><p>- </p></section></section><section id="sec-undefined.-"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">3</a></span>服务间通信</h2><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">3.1</a></span>简介</h3><p>在单体式应用中，各个模块之间的调用是通过编程语言级别的方法或者函数来实现的。但是一个基于微服务的分布式应用是运行在多台机器上的。一般来说，每个服务实例都是一个进程。因此，如下图所示，服务之间的交互必须通过进程间通信（IPC）来实现。</p><p><img src="http://dockerone.com/uploads/article/20150802/1fc9e63825109680c7138b786c6e1c24.png" alt="ipc"/></p><p>后面我们将会详细介绍IPC技术，现在我们先来看下设计相关的问题。</p></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">3.2</a></span>交互模式</h3><p>当为某一个服务选择IPC时，首先需要考虑服务之间如何交互。客户端和服务器之间有很多的交互模式，我们可以从两个维度进行归类。</p><ul><li>第一个维度是一对一还是一对多<ul><li><strong>一对一</strong> 每个客户端请求有一个服务实例来响应。</li><li><strong>一对多</strong> 每个客户端请求有多个服务实例来响应。</li></ul></li><li>第二个维度是这些交互式同步还是异步<ul><li><strong>同步模式</strong> 客户端请求需要服务端即时响应，甚至可能由于等待而阻塞。</li><li><strong>异步模式</strong> 客户端请求不会阻塞进程，服务端的响应可以是非即时的。</li></ul></li></ul><p>下表显示了不同交互模式：</p><p><img src="http://dockerone.com/uploads/article/20150802/ab63cad76d0743e8a77c423eda919a24.jpg" alt="mode"/></p><p>一对一的交互模式有以下几种方式：</p><ul><li>请求/响应：一个客户端向服务器端发起请求，等待响应。客户端期望此响应即时到达。在一个基于线程的应用中，等待过程可能造成线程阻塞。</li><li>通知（也就是常说的单向请求）：一个客户端请求发送到服务端，但是并不期望服务端响应。</li><li>请求/异步响应：客户端发送请求到服务端，服务端异步响应请求。客户端不会阻塞，而且被设计成默认响应不会立刻到达。</li></ul><p>一对多的交互模式有以下几种方式：</p><ul><li>发布/ 订阅模式：客户端发布通知消息，被零个或者多个感兴趣的服务消费。</li><li>发布/异步响应模式：客户端发布请求消息，然后等待从感兴趣服务发回的响应。</li></ul><p>每个服务都是以上这些模式的组合，对某些服务，一个IPC机制就足够了；而对另外一些服务则需要多种IPC机制组合。下图展示了在一个打车服务请求中服务之间是如何通信的。</p><p><img src="http://dockerone.com/uploads/article/20150802/6c6cc8293d2a8334327902edcd32167d.png" alt="ipc2"/></p><p>上图中的服务通信使用了通知、请求/响应、发布/订阅等方式。例如，乘客通过移动端给『行程管理服务』发送通知，希望申请一次出租服务。『行程管理服务』发送请求/响应消息给『乘客服务』以确认乘客账号是有效的。紧接着创建此次行程，并用发布/订阅交互模式通知其他服务，包括定位可用司机的调度服务。</p></section><section id="sec--API"><h3><span class="spec-secid" title="link to this section"><a href="#sec--API">3.3</a></span>定义API</h3><p>API是服务端和客户端之间的契约。不管选择了什么样的IPC机制，重要的是使用某种交互式定义语言（IDL）来精确定义一个服务的API。在开发之前，需要先定义服务的接口，并与客户端开发者详细讨论确认。这样的讨论和设计会大幅度提到API的可用度以及满意度。</p><p>API定义实质上依赖于选择哪种IPC。如果使用消息机制，API则由消息频道（channel）和消息类型构成；如果选择使用HTTP机制，API则由URL和请求、响应格式构成。后面将会详细描述IDL。</p></section><section id="sec-API-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-API-">3.4</a></span>API的演化</h3><p>服务端API会不断变化。在一个单体式应用中经常会直接修改API，然后更新给所有的调用者。而在基于微服务架构应用中，这很困难，即使只有一个服务使用这个API，不可能强迫用户跟服务端保持同步更新。另外，开发者可能会尝试性的部署新版本的服务，这个时候，新旧服务就会同时运行。你需要知道如何处理这些问题。</p><p>你如何处理API变化，这依赖于这些变化有多大。某些改变是微小的，并且可以和之前版本兼容。比如，你可能只是为某个请求和响应添加了一个属性。设计客户端和服务端时候应该遵循健壮性原理，这很重要。客户端使用旧版API应该也能和新版本一起工作。服务端仍然提供默认响应值，客户端忽略此版本不需要的响应。使用IPC机制和消息格式对于API演化很有帮助。</p><p>但是有时候，API需要进行大规模的改动，并且可能与之前版本不兼容。因为你不可能强制让所有的客户端立即升级，所以支持老版本客户端的服务还需要再运行一段时间。如果你正在使用基于基于HTTP机制的IPC，例如REST，一种解决方案是把版本号嵌入到URL中。每个服务都可能同时处理多个版本的API。或者，你可以部署多个实例，每个实例负责处理一个版本的请求。</p></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">3.5</a></span>处理部分失败</h3><p>我们了解到分布式系统中部分失败是普遍存在的问题。因为客户端和服务端是都是独立的进程，一个服务端有可能因为故障或者维护而停止服务，或者此服务因为过载停止或者反应很慢。</p><p>假设推荐服务无法响应请求，那客户端就会由于等待响应而阻塞，这不仅会给客户带来很差的体验，而且在很多应用中还会占用很多资源，比如线程，以至于到最后由于等待响应被阻塞的客户端越来越多，线程资源被耗费完了。如下图所示：</p><p><img src="http://dockerone.com/uploads/article/20150802/4eb9c81e3bb9606f75eccb4f71cc84cb.png" alt="blocked"/></p><p>为了预防这种问题，设计服务时候必须要考虑部分失败的问题。Netfilix提供了一个比较好的解决方案，具体的应对措施包括：</p><ul><li>网络超时：当等待响应时，不要无限期的阻塞，而是采用超时策略。使用超时策略可以确保资源不会无限期的占用。</li><li>限制请求的次数：可以为客户端对某特定服务的请求设置一个访问上限。如果请求已达上限，就要立刻终止请求服务。</li><li>断路器模式（Circuit Breaker Pattern）：记录成功和失败请求的数量。如果失效率超过一个阈值，触发断路器使得后续的请求立刻失败。如果大量的请求失败，就可能是这个服务不可用，再发请求也无意义。在一个失效期后，客户端可以再试，如果成功，关闭此断路器。</li><li>提供回滚：当一个请求失败后可以进行回滚逻辑。例如，返回缓存数据或者一个系统默认值。</li></ul><p>Netflix Hystrix是一个实现相关模式的开源库。如果使用JVM，推荐考虑使用Hystrix。而如果使用非JVM环境，你可以使用类似功能的库。</p></section><section id="sec-IPC-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-IPC-">3.6</a></span>IPC技术</h3><p>现在有很多不同的IPC技术。服务之间的通信可以使用同步的请求/响应模式，比如基于HTTP的REST或者Thrift。另外，也可以选择异步的、基于消息的通信模式，比如AMQP或者STOMP。除以之外，还有其它的消息格式供选择，比如JSON和XML，它们都是可读的，基于文本的消息格式。当然，也还有二进制格式（效率更高）的，比如Avro和Protocol Buffer。接下来我们将会讨论异步的IPC模式和同步的IPC模式，首先来看异步的。</p><section id="sec-IPC-.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-IPC-.-">3.6.1</a></span>异步的，基于消息通信</h4><p>当使用基于异步交换消息的进程通信方式时，一个客户端通过向服务端发送消息提交请求。如果服务端需要回复，则会发送另外一个独立的消息给客户端。因为通信是异步的，客户端不会因为等待而阻塞，相反，客户端理所当然的认为响应不会立刻接收到。</p><p>一个消息由头部（元数据例如发送方）和消息体构成。消息通过channel发送，任何数量的生产者都可以发送消息到channel，同样的，任何数量的消费者都可以从渠道中接受数据。有两类channel，点对点和发布/订阅。点对点channel会把消息准确的发送到某个从channel读取消息的消费者，服务端使用点对点来实现之前提到的一对一交互模式；而发布/订阅则把消息投送到所有从channel读取数据的消费者，服务端使用发布/订阅channel来实现上面提到的一对多交互模式。</p><p>下图展示了打车软件如何使用发布/订阅：</p><p><img src="http://dockerone.com/uploads/article/20150802/0855ed5ec97708bac54acd80af43641e.png" alt="pub"/></p><p>行程管理服务在发布-订阅channel内创建一个行程消息，并通知调度服务有一个新的行程请求，调度服务发现一个可用的司机然后向发布-订阅channel写入司机建议消息（Driver Proposed message）来通知其他服务。</p><p>有很多消息系统可以选择，最好选择一种支持多编程语言的。一些消息系统支持标准协议，例如AMQP和STOMP。其他消息系统则使用独有的协议，有大量开源消息系统可选，比如RabbitMQ、Apache Kafka、Apache ActiveMQ和NSQ。它们都支持某种形式的消息和channel，并且都是可靠的、高性能和可扩展的；然而，它们的消息模型完全不同。</p><p>使用消息机制有很多优点：</p><ul><li><strong>解耦客户端和服务端</strong> 客户端只需要将消息发送到正确的channel。客户端完全不需要了解具体的服务实例，更不需要一个发现机制来确定服务实例的位置。</li><li><strong>Message Buffering</strong> 在一个同步请求/响应协议中，例如HTTP，所有的客户端和服务端必须在交互期间保持可用。而在消息模式中，消息broker将所有写入channel的消息按照队列方式管理，直到被消费者处理。也就是说，在线商店可以接受客户订单，即使下单系统很慢或者不可用，只要保持下单消息进入队列就好了。</li><li><strong>弹性客户端-服务端交互</strong> 消息机制支持以上说的所有交互模式。</li><li><strong>直接进程间通信</strong> 基于RPC机制，试图唤醒远程服务看起来跟唤醒本地服务一样。然而，因为物理定律和部分失败可能性，他们实际上非常不同。消息使得这些不同非常明确，开发者不会出现问题。</li></ul><p>然而，消息机制也有自己的缺点：</p><ul><li><strong>额外的操作复杂性</strong> 消息系统需要单独安装、配置和部署。消息broker（代理）必须高可用，否则系统可靠性将会受到影响。</li><li><strong>实现基于请求/响应交互模式的复杂性</strong> 请求/响应交互模式需要完成额外的工作。每个请求消息必须包含一个回复渠道ID和相关ID。服务端发送一个包含相关ID的响应消息到channel中，使用相关ID来将响应对应到发出请求的客户端。也许这个时候，使用一个直接支持请求/响应的IPC机制会更容易些。</li></ul></section><section id="sec--IPC"><h4><span class="spec-secid" title="link to this section"><a href="#sec--IPC">3.6.2</a></span>同步的，基于请求/响应的IPC</h4><p>当使用一个同步的，基于请求/响应的IPC机制，客户端向服务端发送一个请求，服务端处理请求，返回响应。一些客户端会由于等待服务端响应而被阻塞，而另外一些客户端也可能使用异步的、基于事件驱动的客户端代码（Future或者Rx Observable的封装）。然而，不像使用消息机制，客户端需要响应及时返回。这个模式中有很多可选的协议，但最常见的两个协议是REST和Thrift。首先我们来看下REST。</p><section id="sec-REST"><h5><span class="spec-secid" title="link to this section"><a href="#sec-REST">3.6.2.1</a></span>REST</h5><p>现在很流行使用RESTful风格的API。REST是基于HTTP协议的。另外，一个需要理解的比较重要的概念是，REST是一个资源，一般代表一个业务对象，比如一个客户或者一个产品，或者一组商业对象。REST使用HTTP语法协议来修改资源，一般通过URL来实现。举个例子，GET请求返回一个资源的简单信息，响应格式通常是XML或者JSON对象格式。POST请求会创建一个新资源，PUT请求更新一个资源。这里引用下REST之父Roy Fielding说的：</p><p>下图展示了打车软件是如何使用REST的。</p><p><img src="http://dockerone.com/uploads/article/20150802/188f16abf54a6fc3446d51dc3625e571.png" alt="rest"/></p><p>乘客通过移动端向行程管理服务的/trips资源提交了一个POST请求。行程管理服务收到请求之后，会发送一个GET请求到乘客管理服务以获取乘客信息。当确认乘客信息之后，紧接着会创建一个行程，并向移动端返回201（译者注：状态码）响应。</p><p>很多开发者都表示他们基于HTTP的API是RESTful的。但是，如同Fielding在他的博客中所说，这些API可能并不都是RESTful的。Leonard Richardson为REST定义了一个成熟度模型，具体包含以下4个层次（摘自IBM）：</p><ul><li>第一个层次（Level 0）的 Web 服务只是使用 HTTP 作为传输方式，实际上只是远程方法调用（RPC）的一种具体形式。SOAP 和 XML&#8208;RPC 都属于此类。</li><li>第二个层次（Level 1）的 Web 服务引入了资源的概念。每个资源有对应的标识符和表达。</li><li>第三个层次（Level 2）的 Web 服务使用不同的 HTTP 方法来进行不同的操作，并且使用 HTTP 状态码来表示不同的结果。如 HTTP GET 方法来获取资源，HTTP DELETE 方法来删除资源。</li><li>第四个层次（Level 3）的 Web 服务使用 HATEOAS。在资源的表达中包含了链接信息。客户端可以根据链接来发现可以执行的动作。</li></ul><p>使用基于HTTP的协议有如下好处：</p><ul><li>HTTP非常简单并且大家都很熟悉。</li><li>可以使用浏览器扩展（比如Postman）或者curl之类的命令行来测试API。</li><li>内置支持请求/响应模式的通信。</li><li>HTTP对防火墙友好的。</li><li>不需要中间代理，简化了系统架构。</li></ul><p>不足之处包括：</p><ul><li>只支持请求/响应模式交互。可以使用HTTP通知，但是服务端必须一直发送HTTP响应才行。</li><li>因为客户端和服务端直接通信（没有代理或者buffer机制），在交互期间必须都在线。</li><li>客户端必须知道每个服务实例的URL。如之前那篇关于API Gateway的文章所述，这也是个烦人的问题。客户端必须使用服务实例发现机制。</li></ul></section><section id="sec-Thrift"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Thrift">3.6.2.2</a></span>Thrift</h5><p>Apache Thrift是一个很有趣的REST的替代品。它是Facebook实现的一种高效的、支持多种编程语言的远程服务调用的框架。Thrift提供了一个C风格的IDL定义API。使用Thrift编译器可以生成客户端和服务器端代码框架。编译器可以生成多种语言的代码，包括C++、Java、Python、PHP、Ruby, Erlang和Node.js。</p><p>Thrift接口包括一个或者多个服务。服务定义类似于一个JAVA接口，是一组方法。Thrift方法可以返回响应，也可以被定义为单向的。返回值的方法其实就是请求/响应类型交互模式的实现。客户端等待响应，并可能抛出异常。单向方法对应于通知类型的交互模式，服务端并不返回响应。</p><p>Thrift支持多种消息格式：JSON、二进制和压缩二进制。二进制比JSON更高效，因为二进制解码更快。同样原因，压缩二进制格式可以提供更高级别的压缩效率。JSON，是易读的。Thrift也可以在裸TCP和HTTP中间选择，裸TCP看起来比HTTP更加有效。然而，HTTP对防火墙，浏览器和人来说更加友好。</p></section><section id="sec--IPC.-"><h5><span class="spec-secid" title="link to this section"><a href="#sec--IPC.-">3.6.2.3</a></span>消息格式</h5><p>了解完HTTP和Thrift后，我们来看下消息格式方面的问题。如果使用消息系统或者REST，就可以选择消息格式。其它的IPC机制，例如Thrift可能只支持部分消息格式，也许只有一种。无论哪种方式，我们必须使用一个跨语言的消息格式，这非常重要。因为指不定哪天你会使用其它语言。</p><p>有两类消息格式：文本和二进制。文本格式的例子包括JSON和XML。这种格式的优点在于不仅可读，而且是自描述的。在JSON中，一个对象就是一组键值对。类似的，在XML中，属性是由名字和值构成。消费者可以从中选择感兴趣的元素而忽略其它部分。同时，小幅度的格式修改可以很容器向后兼容。</p><p>XML文档结构是由XML schema定义的。随着时间发展，开发者社区意识到JSON也需要一个类似的机制。一个选择是使用JSON Schema，要么是独立的，要么是例如Swagger的IDL。</p><p>基于文本的消息格式最大的缺点是消息会变得冗长，特别是XML。因为消息是自描述的，所以每个消息都包含属性和值。另外一个缺点是解析文本的负担过大。所以，你可能需要考虑使用二进制格式。</p><p>二进制的格式也有很多。如果使用的是Thrift RPC，那可以使用二进制Thrift。如果选择消息格式，常用的还包括Protocol Buffers和Apache Avro。它们都提供典型的IDL来定义消息架构。一个不同点在于Protocol Buffers使用的是加标记（tag）的字段，而Avro消费者需要知道模式（schema）来解析消息。因此，使用前者，API更容易演进。这篇博客很好的比较了Thrift、Protocol Buffers、Avro三者的区别。</p></section></section></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">3.7</a></span>总结</h3><p>微服务必须使用进程间通信机制来交互。当设计服务的通信模式时，你需要考虑几个问题：服务如何交互，每个服务如何标识API，如何升级API，以及如何处理部分失败。微服务架构有两类IPC机制可选，异步消息机制和同步请求/响应机制。 </p></section></section><section id="sec-undefined.-"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">4</a></span>服务发现</h2><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.1</a></span>为什么要使用服务发现?</h3><p>设想一下，我们正在写代码使用了提供REST API或者Thrift API的服务，为了完成一次服务请求，代码需要知道服务实例的网络位置（IP地址和端口）。传统应用都运行在物理硬件上，服务实例的网络位置都是相对固定的。例如，代码可以从一个经常变更的配置文件中读取网络位置。</p><p>而对于一个现代的，基于云微服务的应用来说，这却是一个很麻烦的问题。其架构如图所示，服务实例的网络位置都是动态分配的，而且因为扩展、失效和升级等需求，服务实例会经常动态改变，因此，客户端代码需要使用一种更加复杂的服务发现机制。</p><p><img src="http://dockerone.com/uploads/article/20151027/bfcc845a921c118b25959c7f534144bb.png" alt="sd"/></p><p>目前有两大类服务发现模式：客户端发现和服务端发现。</p></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.2</a></span>客户端发现模式</h3><p>当使用客户端发现模式时，客户端负责决定相应服务实例的网络位置，并且对请求实现负载均衡。客户端从一个服务注册服务中查询，其中是所有可用服务实例的库。客户端使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。下图显示的是这种模式的架构图：</p><p><img src="http://dockerone.com/uploads/article/20151027/fa07cb312fb9f16ac094793b3aeae8cd.png" alt="csd"/></p><p>服务实例的网络位置是在启动时注册到服务注册表中，并且在服务终止时从注册表中删除。服务实例注册信息一般是使用心跳机制来定期刷新的。</p><p>客户端发现模式也是优缺点分明。</p><ul><li><strong>优点</strong> 这种模式相对比较直接，而且除了服务注册表，没有其它改变的因素。除此之外，因为客户端知道可用服务注册表信息，因此客户端可以通过使用哈希一致性（hashing consistently）变得更加聪明，更加有效的负载均衡。</li><li><strong>缺点</strong> 而这种模式一个最大的缺点是需要针对不同的编程语言注册不同的服务，在客户端需要为每种语言开发不同的服务发现逻辑</li></ul></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.3</a></span>服务端发现</h3><p>另外一种服务发现的模式是服务端发现模式（server&#8208;side discovery pattern），下图展现了这种模式的架构图，客户端通过负载均衡器向某个服务提出请求，负载均衡器向服务注册表发出请求，将每个请求转发往可用的服务实例。跟客户端发现一样，服务实例在服务注册表中注册或者注销。</p><p><img src="http://dockerone.com/uploads/article/20151027/8d56ee2154b5f809fb055d5a894b7fed.png" alt="ssd"/></p><p>服务端发现模式也有优缺点。</p><ul><li><strong>优点</strong> 最大的优点是客户端无需关注发现的细节，客户端只需要简单的向负载均衡器发送请求，实际上减少了编程语言框架需要完成的发现逻辑。而且，如上说所，某些部署环境免费提供以上功能。</li><li><strong>缺点</strong> 这种模式也有缺陷，除非部署环境提供负载均衡器，否则负载均衡器是另外一个需要配置管理的高可用系统功能。</li></ul></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.4</a></span>服务注册表</h3><p>服务注册表是服务发现很重要的部分，它是包含服务实例网络地址的数据库。服务注册表需要高可用而且随时更新。客户端可以缓存从服务注册表获得的网络地址。然而，这些信息最终会变得过时，客户端也无法发现服务实例。因此，服务注册表由若干使用复制协议保持同步的服务器构成。</p><p>一些服务注册表例子包括：</p><ul><li><a href="https://github.com/coreos/etcd">etcd</a> &ndash; 是一个高可用，分布式的，一致性的，键值表，用于共享配置和服务发现。两个著名案例包括Kubernetes和Cloud Foundry。</li><li><a href="https://www.consul.io/">consul</a> &ndash; 是一个用于发现和配置的服务。提供了一个API允许客户端注册和发现服务。Consul可以用于健康检查来判断服务可用性。</li><li><a href="http://zookeeper.apache.org/">ZooKeeper</a> &ndash; 是一个广泛使用，为分布式应用提供高性能整合的服务。Apache ZooKeeper最初是Hadoop的子项目，现在已经变成顶级项目。</li></ul></section><section id="sec-undefined.-.-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.5</a></span>服务注册选项</h3><p>服务实例必须向注册表中注册和注销，如何注册和注销也有一些不同的方式。一种方式是服务实例自己注册，也叫自注册模式（self&#8208;registration pattern）；另外一种方式是为其它系统提供服务实例管理的，也叫第三方注册模式（third party registration pattern）。</p><section id="sec-undefined.-.-.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-.-">4.5.1</a></span>自注册方式</h4><p>当使用自注册模式时，服务实例负责在服务注册表中注册和注销。另外，如果需要的话，一个服务实例也要发送心跳来保证注册信息不会过时。下图描述了这种架构：</p><p><img src="http://dockerone.com/uploads/article/20151027/feaf189840fb748843da73119fe83cdd.png" alt="sreg"/></p><ul><li><strong>优点</strong> 相对简单，不需要其他系统功能</li><li><strong>缺点</strong> 把服务实例跟服务注册表联系起来。必须在每种编程语言和框架内部实现注册代码。</li></ul></section><section id="sec-undefined.-.-.-"><h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-.-">4.5.2</a></span>第三方注册模式</h4><p>当使用第三方注册模式时，服务实例并不负责向服务注册表注册，而是由另外一个系统模块，叫做服务管理器，负责注册。服务管理器通过查询部署环境或订阅事件来跟踪运行服务的改变。当管理器发现一个新可用服务，会向注册表注册此服务。服务管理器也负责注销终止的服务实例。下图是这种模式的架构图。</p><p><img src="http://dockerone.com/uploads/article/20151027/d30be665a883246607b13bed4e10e58c.png" alt="treg"/></p><ul><li><strong>优点</strong> 服务跟服务注册表是分离的，不需要为每种编程语言和架构完成服务注册逻辑，替代的，服务实例是通过一个集中化管理的服务进行管理的。</li><li><strong>缺点</strong> 除非这种服务被内置于部署环境中，否则也需要配置管理一个高可用的系统。 </li></ul></section></section></section><section id="sec-undefined.-"><h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">A</a></span>参考</h2><ul><li><a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-01">解析微服务架构（一）单块架构系统以及其面临的挑战</a></li><li><a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-02">解析微服务架构（二）微服务架构综述</a></li><li><a href="http://dockone.io/article/394">微服务实战（一）：微服务架构的优势与不足</a></li><li><a href="http://dockone.io/article/482">微服务实战（二）：使用API Gateway</a></li><li><a href="http://dockone.io/article/549">微服务实战（三）：深入微服务架构的进程间通信</a></li><li><a href="http://dockone.io/article/771">微服务实战（四）：服务发现的可行方案以及实践案例</a></li><li><a href="http://dockone.io/article/936">微服务实践（五）：微服务的事件驱动数据管理</a> </li></ul></section><footer>Written in <a href="http://leebyron.com/spec-md/" target="_blank">Spec Markdown</a>.</footer></body></html>